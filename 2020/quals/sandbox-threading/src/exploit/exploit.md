# Exploit

The bug in this challenge has to do with how native threads are suspended in the threading library. This happens when there are fewer runnable userland threads than there are underlying pthreads.

## An Example of Correct Behavior
Let's say a thread is blocking on a semaphore, and there are no userland threads ready to be run. That means the underlying pthread needs to be suspended. Here's what happens.

1. Userland thread A is running on pthread 1. It blocks on a semaphore.
2. There are no userland threads on the ready queue.
3. Thread A pushes its contect onto the semaphore's wait queue.
4. Thread A calls `swapcontext()` to switch to a dedicated "sleeper thread". Each Pthread has such a thread.
5. Thread A suspends itself.
6. Thread B is running on pthread 2.
7. Thread B calls `up()` on some other semaphore, unblocking userland thread C.
8. Since there's now work available, thread B pushes thread C's context onto the ready queue, and signals pthread 1.
9. pthread 1 wakes up, sees that there's something on the ready queue.
10. pthread 1 calls `swapcontext()` to switch to thread C, and switches away from its sleeper thread.

This is what this library would do, if it were correct.

## The Bug

**Step 4 is missing**. There is no dedicated sleeper thread. When a thread suspends itself, it pushes its thread context onto a wait queue, and then *suspends itself without doing a context switch*. This means that the context on the wait queue points to the same stack as the suspended pthread.

If the context on the wait queue is awoken first, it will start using its stack. If the pthread is subsequently awoken, it will also use the same stack, which has now been clobbered.

The exploit relies upon this: unblock some thread that *used* to be on a now-sleeping pthread, and have it fill its stack with some pointers to shellcode. Then, awaken the pthread. The next time it `return`s, it will jump to your shellcode.

The easiest way to get a pointer to some shellcode is to allocate a global `ref<array<char, size>>`, and then print the `ref` out. This prints the address the `ref` refers to, which will be the array contents. Then, accept that address back on stdin, thereby laundering it from a pointer into an integer.
